package us.dit.service.model.entities.score

import java.lang.Math
import java.time.temporal.ChronoUnit
import us.dit.service.model.entities.Doctor
import us.dit.service.model.entities.ShiftAssignment
import us.dit.service.model.entities.DayConfiguration
import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScoreHolder

global HardSoftScoreHolder scoreHolder

dialect "mvel"

// ============================================================================
// HARD CONSTRAINTS
// ============================================================================

rule "Every shift must have a doctor"
// Ensures that every generated shift has a doctor assigned
// It penalizes any shift with no doctor == null
    when 
        $config : GuardianesConstraintConfiguration()
        ShiftAssignment( doctor == null )
    then
        scoreHolder.addHardConstraintMatch(kcontext, - $config.getEveryShiftAssigned().getHardScore());
end

rule "Doctor eligibility for Guardias"
// Prevents assigning a "GUARDIA" shift to a doctor who is not eligible to perform them (checked via 'doesCycleShifts == false')
    when
        $config : GuardianesConstraintConfiguration()
        ShiftAssignment(
            doctor != null,
            shift.shiftType == "GUARDIA",
            doctor.shiftConfiguration.doesCycleShifts == false
        )
    then
        scoreHolder.addHardConstraintMatch(kcontext, - $config.getEligibilityCycle().getHardScore());
end

rule "Holidays for a doctor"
// Respects time off It penalizes the score if a shift is assigned 
// It penalizes the score if a shift is assigned to a doctor on a date marked as an absence (holiday, sick leave, etc.)
    when
        $config : GuardianesConstraintConfiguration()
        ShiftAssignment(
            $doc : doctor != null,
            $date : dayConfiguration.date
        )
        eval($doc.getAbsence() != null && $doc.getAbsence().isAbsentOn($date))
    then
        scoreHolder.addHardConstraintMatch(kcontext, - $config.getHolidays().getHardScore());
end

rule "Incompatible: Consulta is exclusive"
// Defines "CONSULTA" as an exclusive shift. 
// If a doctor has a consultation, they cannot be assigned any other shift type on the same day
    when
        $config : GuardianesConstraintConfiguration()
        $d : Doctor()
        $day : DayConfiguration()
        $a1 : ShiftAssignment(doctor == $d, dayConfiguration == $day, shift.shiftType == "CONSULTA")
        exists ShiftAssignment(doctor == $d, dayConfiguration == $day, this != $a1)
    then
        scoreHolder.addHardConstraintMatch(kcontext, - $config.getIncompatibleConsulta().getHardScore());
end

rule "Incompatible: No duplicate types"
// Prevents a doctor from having two shifts of the exact same type assigned on the same day
    when
        $config : GuardianesConstraintConfiguration()
        $d : Doctor()
        $day : DayConfiguration()
        $a1 : ShiftAssignment(doctor == $d, dayConfiguration == $day, $type : shift.shiftType)
        $a2 : ShiftAssignment(doctor == $d, dayConfiguration == $day, this != $a1, shift.shiftType == $type)
        eval($a1.getId() < $a2.getId())
    then
        scoreHolder.addHardConstraintMatch(kcontext, - $config.getIncompatibleDuplicates().getHardScore());
end

rule "Linking: Shifts only when Cycle Shifts"
// For doctors with this specific constraint ('hasShiftsOnlyWhenCycleShifts'),
// a "TARDE" shift is only valid if they are also assigned a "GUARDIA" shift on that same day
    when
        $config : GuardianesConstraintConfiguration()
        $doc : Doctor(shiftConfiguration.hasShiftsOnlyWhenCycleShifts == true)
        // Tiene TARDE
        $tarde : ShiftAssignment(
            doctor == $doc, 
            shift.shiftType == "TARDE",
            $day : dayConfiguration
        )
        // NO tiene GUARDIA
        not ShiftAssignment(
            doctor == $doc, 
            dayConfiguration == $day, 
            shift.shiftType == "GUARDIA"
        )
    then
        scoreHolder.addHardConstraintMatch(kcontext, - $config.getConditionalShifts().getHardScore());
end

rule "Doctor Max Shifts (Cont. Asist)"
// Penalizes the solution if the number of "TARDE" shifts assigned to a doctor exceeds their maximum contractual limit
    when
        $config : GuardianesConstraintConfiguration()
        $doc : Doctor($max : shiftConfiguration.maxShifts)
        $count : Number(intValue > $max) from accumulate(
            ShiftAssignment(doctor == $doc, shift.shiftType == "TARDE"),
            count()
        )
    then
        int penalization = $count.intValue() - $max;
        scoreHolder.addHardConstraintMatch(kcontext, - ($config.getDoctorMaxShifts().getHardScore() * penalization));
end

rule "Doctor Min Shifts Hard (Cont. Asist)"
// Penalizes the solution if the number of "TARDE" shifts assigned to a doctor falls behind their minimum contractual limit
    when
        $config : GuardianesConstraintConfiguration()
        $doc : Doctor($min : shiftConfiguration.minShifts)
        $count : Number(intValue < $min) from accumulate(
            ShiftAssignment(doctor == $doc, shift.shiftType == "TARDE"),
            count()
        )
    then
        int missing = $min - $count.intValue();
        scoreHolder.addHardConstraintMatch(kcontext, - ($config.getDoctorMinShiftsHard().getHardScore() * missing));
end

rule "Strict Consultations Count"
// Enforces that a doctor is assigned exactly the number of "CONSULTA" shifts defined in their contract 
    when
        $config : GuardianesConstraintConfiguration()
        $doc : Doctor($expected : shiftConfiguration.numConsultations, $expected > 0)
        $count : Number() from accumulate(
            ShiftAssignment(doctor == $doc, shift.shiftType == "CONSULTA"),
            count()
        )
        eval($count.intValue() != $expected)
    then
        int diff = Math.abs($count.intValue() - $expected);
        scoreHolder.addHardConstraintMatch(kcontext, - ($config.getDoctorSpecificConsultations().getHardScore() * diff));
end


// ============================================================================
// SOFT CONSTRAINTS
// ============================================================================

rule "Fairness in Guardias"
// Aims to distribute "GUARDIA" shifts evenly among all doctors
// It uses a quadratic penalty (N^2) to punish outliers (doctors with significantly more shifts) more severely
    when
        $config : GuardianesConstraintConfiguration()
        $doc : Doctor(shiftConfiguration.doesCycleShifts == true)
        $count : Number() from accumulate(
            ShiftAssignment(doctor == $doc, shift.shiftType == "GUARDIA"),
            count()
        )
    then
        int penalization = $count.intValue() * $count.intValue();
        scoreHolder.addSoftConstraintMatch(kcontext, - ($config.getFairnessGuardias().getSoftScore() * penalization));
end

rule "Minimum days between Guardias"
// Attempts to enforce a spacing of at least 3 days between two "GUARDIA" shifts for the same doctor to ensure adequate rest
    when
        $config : GuardianesConstraintConfiguration()
        $a1 : ShiftAssignment($d : doctor, shift.shiftType == "GUARDIA", $date1 : dayConfiguration.date, $id1 : id)
        $a2 : ShiftAssignment(doctor == $d, shift.shiftType == "GUARDIA", $date2 : dayConfiguration.date, id > $id1)
        eval(Math.abs(ChronoUnit.DAYS.between($date1, $date2)) < 3)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, - $config.getMinDaysBetweenGuardias().getSoftScore());
end

rule "Avoid consecutive Tardes"
// Tries to avoid assigning "TARDE" shifts on consecutive days to prevent fatigue and improve the doctor's schedule quality
    when
        $config : GuardianesConstraintConfiguration()
        $d : Doctor()
        $a1 : ShiftAssignment(doctor == $d, shift.shiftType == "TARDE", $date1 : dayConfiguration.date)
        $a2 : ShiftAssignment(doctor == $d, shift.shiftType == "TARDE", $date2 : dayConfiguration.date, this != $a1)
        eval(Math.abs(ChronoUnit.DAYS.between($date1, $date2)) == 1)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, - $config.getAvoidConsecutiveTardes().getSoftScore());
end